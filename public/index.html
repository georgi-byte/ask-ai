<script>
const translations = {
  en: { appTitle: "Ask AI", language: "🌐 Language: English", placeholder: "Ask me anything...", send: "Send", speak: "🎤 Talk", listening: "🎤 Listening... Speak now." },
  bg: { appTitle: "Попитай AI", language: "🌐 Език: Български", placeholder: "Попитай ме нещо...", send: "Изпрати", speak: "🎤 Говори", listening: "🎤 Слушам... Говори сега." },
  de: { appTitle: "Frag die KI", language: "🌐 Sprache: Deutsch", placeholder: "Frag mich etwas...", send: "Senden", speak: "🎤 Sprechen", listening: "🎤 Ich höre zu... Sprich jetzt." }
};

let currentLang = 'en';
let microphoneUsed = false;
let userCity = null;
let userTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;

const appTitle = document.getElementById('appTitle');
const languageToggleBtn = document.getElementById('languageToggleBtn');
const darkModeBtn = document.getElementById('darkModeBtn');
const userInput = document.getElementById('userInput');
const sendMessageBtn = document.getElementById('sendMessageBtn');
const speakBtn = document.getElementById('speakBtn');
const chatBox = document.getElementById('chatBox');

// 🌍 Get city from coordinates
if (navigator.geolocation) {
  navigator.geolocation.getCurrentPosition(async (pos) => {
    const { latitude, longitude } = pos.coords;
    try {
      const res = await fetch(
        `https://nominatim.openstreetmap.org/reverse?lat=${latitude}&lon=${longitude}&format=json`
      );
      const data = await res.json();
      userCity = data.address.city || data.address.town || data.address.village || data.address.country;
    } catch (err) {
      console.log("Could not get city", err);
    }
  });
}

function updateLanguage() {
  const t = translations[currentLang];
  appTitle.textContent = t.appTitle;
  languageToggleBtn.textContent = t.language;
  userInput.placeholder = t.placeholder;
  sendMessageBtn.textContent = t.send;
  speakBtn.textContent = t.speak;
}
languageToggleBtn.addEventListener('click', () => {
  currentLang = currentLang === 'en' ? 'bg' : currentLang === 'bg' ? 'de' : 'en';
  updateLanguage();
});
updateLanguage();
darkModeBtn.addEventListener('click', () => document.body.classList.toggle('dark'));

function speakText(text) {
  const utter = new SpeechSynthesisUtterance(text);
  utter.lang = currentLang === 'en' ? 'en-US' : currentLang === 'bg' ? 'bg-BG' : 'de-DE';
  speechSynthesis.speak(utter);
}

function appendMessage(text, type) {
  const div = document.createElement('div');
  div.className = `message ${type}`;
  div.innerHTML = `${text.replace(/\n/g,'<br>')}`;
  if (type === 'bot') {
    const btn = document.createElement('button');
    btn.textContent = '🔊';
    btn.className = 'read-btn';
    btn.addEventListener('click', () => speakText(text));
    div.appendChild(btn);
  }
  chatBox.appendChild(div);
  chatBox.scrollTop = chatBox.scrollHeight;
}

userInput.addEventListener('keydown', e => {
  if (e.key === 'Enter') sendMessageBtn.click();
});

sendMessageBtn.addEventListener('click', async () => {
  const msg = userInput.value.trim();
  if (!msg) return;
  appendMessage(msg, 'user');
  userInput.value = '';

  // typing dots
  const typingDiv = document.createElement('div');
  typingDiv.className = 'typing';
  typingDiv.innerHTML = '<span></span><span></span><span></span>';
  chatBox.appendChild(typingDiv);
  chatBox.scrollTop = chatBox.scrollHeight;

  try {
    const res = await fetch('/api/chat', {
      method: 'POST',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify({ 
        message: msg,
        language: currentLang,
        city: userCity,
        timezone: userTimezone
      })
    });
    const data = await res.json();
    chatBox.removeChild(typingDiv);
    appendMessage(data.reply, 'bot');
    if (microphoneUsed) {
      speakText(data.reply);
      microphoneUsed = false;
    }
  } catch {
    chatBox.removeChild(typingDiv);
    appendMessage("⚠️ AI is offline", 'bot');
  }
});

speakBtn.addEventListener('click', () => {
  if (!('webkitSpeechRecognition' in window)) {
    appendMessage("⚠️ Browser does not support speech", 'bot');
    return;
  }
  const recog = new webkitSpeechRecognition();
  recog.lang = currentLang === 'en' ? 'en-US' : currentLang === 'bg' ? 'bg-BG' : 'de-DE';
  appendMessage(translations[currentLang].listening, 'bot');
  recog.start();
  recog.onresult = e => {
    microphoneUsed = true;
    const transcript = e.results[0][0].transcript;
    userInput.value = transcript;
    sendMessageBtn.click();
  };
});
</script>
